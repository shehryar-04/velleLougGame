<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scrolling Path Game - 4 Lanes Responsive</title>
<style>
body {
  margin: 0;
  background: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  font-family: Arial, sans-serif;
  position: relative;
  flex-direction: column;
}

canvas {
  border: 2px solid white;
  background: #333;
  display: none;
  touch-action: none; /* prevent scrolling */
  width: 90vw;       /* responsive width */
  max-width: 400px;  /* maximum width for desktop */
  height: calc(90vw * 1.5); /* maintain 2:3 aspect ratio */
  max-height: 600px; /* maximum height for desktop */
}

.overlay {
  position: absolute;
  text-align: center;
  color: white;
  display: none;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  margin-top: 10px;
  margin-right: 5px;
}

#levelSelect {
  color: white;
}
</style>
</head>
<body>

<div id="levelSelect">
  <h1>Select Level (1â€“15)</h1>
  <div id="levelButtons"></div>
</div>

<canvas id="game" width="400" height="600"></canvas>

<div class="overlay" id="gameOverScreen">
  <h1 id="gameOverText">Game Over</h1>
  <p id="finalTime"></p>
  <button onclick="showLevelSelect()">Choose Level</button>
  <button onclick="resetGame()">Try Again</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const gameOverScreen = document.getElementById("gameOverScreen");
const finalTimeText = document.getElementById("finalTime");
const gameOverText = document.getElementById("gameOverText");
const levelSelectDiv = document.getElementById("levelSelect");
const levelButtonsDiv = document.getElementById("levelButtons");

// Lane settings
const LANE_COUNT = 4;
let LANES = [];

// Player image and size
const PLAYER_WIDTH = 50;
const PLAYER_HEIGHT = 80;
const playerImg = new Image();
playerImg.src = './car2.png'; // <-- replace with your player image path
const player = { lane:1, x:0, y:0, width:PLAYER_WIDTH, height:PLAYER_HEIGHT, speed:6 };

// Game state
let bgSpeed, lineOffset, obstacles, frame, gameOver;

// Timer
let startTime, levelTime, levelDuration;

// Level
let level = 1;

// Obstacle image and size
const OBSTACLE_WIDTH = 40;
const OBSTACLE_HEIGHT = 80;
const obstacleImg = new Image();
obstacleImg.src = './car2.png'; // <-- replace with your obstacle image path
let obstacleSpeed, spawnRate;

// Controls
let left=false, right=false;

// Level data
const levelData = [];
for(let i=1;i<=15;i++){
  levelData.push({
    bgSpeed: 4 + i*0.5,
    obstacleSpeed: 2 + i*0.3,
    spawnRate: Math.max(20, 90 - i*5)
  });
}

// Level selection buttons
for(let i=1;i<=15;i++){
  const btn = document.createElement("button");
  btn.textContent = i;
  btn.onclick = ()=>startLevel(i);
  levelButtonsDiv.appendChild(btn);
}

// Keyboard controls
document.addEventListener("keydown", e => { 
  if(e.key==="ArrowLeft") left=true; 
  if(e.key==="ArrowRight") right=true; 
});
document.addEventListener("keyup", e => { 
  if(e.key==="ArrowLeft") left=false; 
  if(e.key==="ArrowRight") right=false; 
});

// Swipe controls
let touchStartX = null;
canvas.addEventListener("touchstart", e => {
  touchStartX = e.touches[0].clientX;
});
canvas.addEventListener("touchend", e => {
  if(touchStartX === null) return;
  const touchEndX = e.changedTouches[0].clientX;
  const diff = touchEndX - touchStartX;
  const swipeThreshold = 30;
  if(diff > swipeThreshold) right = true;
  else if(diff < -swipeThreshold) left = true;
  touchStartX = null;
});

// Update lanes based on canvas size
function updateLaneCenters() {
  const actualWidth = canvas.clientWidth;
  const margin = 20 * (actualWidth / 400); 
  const roadWidth = actualWidth - 2 * margin;
  const laneWidth = roadWidth / LANE_COUNT;
  LANES = [];
  for(let i=0;i<LANE_COUNT;i++){
    LANES.push(margin + i*laneWidth + laneWidth/2);
  }
}

// Call initially and on resize
updateLaneCenters();
window.addEventListener('resize', updateLaneCenters);

// Start level
function startLevel(lvl){
  level = lvl;
  const data = levelData[lvl-1];
  bgSpeed = data.bgSpeed;
  obstacleSpeed = data.obstacleSpeed;
  spawnRate = data.spawnRate;

  lineOffset = 0;
  obstacles = [];
  frame = 0;
  gameOver = false;

  levelDuration = 30;
  levelTime = 0;

  player.lane = 1;
  player.x = LANES[player.lane] - player.width/2;
  player.y = canvas.height-100;

  startTime = Date.now();

  levelSelectDiv.style.display = "none";
  canvas.style.display = "block";
  gameOverScreen.style.display="none";
}

function showLevelSelect(){
  canvas.style.display="none";
  gameOverScreen.style.display="none";
  levelSelectDiv.style.display="block";
}

function resetGame(){
  startLevel(level);
}

// Spawn obstacles in lanes
function spawnObstacle() {
  const lane = Math.floor(Math.random() * LANE_COUNT);
  const x = LANES[lane] - OBSTACLE_WIDTH/2;
  obstacles.push({x, y:-OBSTACLE_HEIGHT, width: OBSTACLE_WIDTH, height: OBSTACLE_HEIGHT});
}

function updateObstacles() {
  for(let i=obstacles.length-1; i>=0; i--){
    obstacles[i].y += obstacleSpeed;
    if(obstacles[i].y > canvas.height) obstacles.splice(i,1);
  }
}

// Collision detection
function checkCollision(a,b){
  return a.x < b.x + b.width &&
         a.x + a.width > b.x &&
         a.y < b.y + b.height &&
         a.y + a.height > b.y;
}

// Game update
function update() {
  if(gameOver) return;

  if(left) { player.lane = Math.max(0, player.lane-1); left=false; }
  if(right) { player.lane = Math.min(LANE_COUNT-1, player.lane+1); right=false; }
  player.x = LANES[player.lane] - player.width/2;

  lineOffset += bgSpeed;
  if(lineOffset>40) lineOffset=0;

  frame++;
  if(frame % Math.floor(spawnRate) === 0) spawnObstacle();
  updateObstacles();

  for(const obs of obstacles){
    if(checkCollision(player, obs)){
      gameOver=true;
      const elapsedTime = ((Date.now()-startTime)/1000).toFixed(2);
      finalTimeText.textContent=`Time Survived: ${elapsedTime}s`;
      gameOverScreen.style.display="block";
      return;
    }
  }

  levelTime = (Date.now()-startTime)/1000;
  if(levelTime >= levelDuration){
    gameOver = true;
    gameOverText.textContent = "Level Completed!";
    finalTimeText.textContent = `You completed level ${level}!`;
    gameOverScreen.style.display="block";
  }
}

// Draw functions
function drawBackground(){
  ctx.fillStyle="#555";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#222";
  ctx.fillRect(0,0,20,canvas.height);
  ctx.fillRect(canvas.width-20,0,20,canvas.height);

  ctx.strokeStyle="#eee";
  ctx.lineWidth=4;
  ctx.setLineDash([20,20]);
  ctx.lineDashOffset=-lineOffset;
  for(let i=1; i<LANE_COUNT; i++){
    const x = 20 + i*((canvas.width-40)/LANE_COUNT);
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,canvas.height);
    ctx.stroke();
  }
  ctx.setLineDash([]);
}

function drawObstacles(){
  for(const obs of obstacles){
    ctx.drawImage(obstacleImg, obs.x, obs.y, obs.width, obs.height);
  }
}

function drawPlayer(){
  ctx.drawImage(playerImg, player.x, player.y, player.width, player.height);
}

function drawHUD(){
  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText(`Level: ${level}`,10,30);

  if(!gameOver){
    const remaining = (levelDuration - levelTime).toFixed(2);
    ctx.fillText(`Time: ${remaining}s`, canvas.width-120,30);
  }
}

// Game loop
function gameLoop(){
  if(canvas.style.display === "block"){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    update();
    drawObstacles();
    drawPlayer();
    drawHUD();
  }
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>

</body>
</html>
