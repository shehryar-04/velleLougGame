<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Scrolling Path Game - Fixed Lanes</title>
<style>
body {
  margin: 0;
  background: #111;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  font-family: Arial, sans-serif;
  flex-direction: column;
}

canvas {
  border: 2px solid white;
  background: #333;
  display: none;
  touch-action: none;
  width: 90vw;
  max-width: 400px;
  height: calc(90vw * 1.5);
  max-height: 600px;
}

.overlay {
  position: absolute;
  text-align: center;
  color: white;
  display: none;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
}

button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  margin-top: 10px;
  margin-right: 5px;
}

#levelSelect { color: white; }
</style>
</head>
<body>

<div id="levelSelect">
  <h1>Select Level (1â€“15)</h1>
  <div id="levelButtons"></div>
</div>

<canvas id="game" width="400" height="600"></canvas>

<div class="overlay" id="gameOverScreen">
  <h1 id="gameOverText">Game Over</h1>
  <p id="finalTime"></p>
  <button onclick="showLevelSelect()">Choose Level</button>
  <button onclick="resetGame()">Try Again</button>
</div>

<!-- Crash sound -->
<audio id="crashSound" src="./laude-lag-gaye.mp3" preload="auto"></audio>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");
const gameOverScreen = document.getElementById("gameOverScreen");
const finalTimeText = document.getElementById("finalTime");
const gameOverText = document.getElementById("gameOverText");
const levelSelectDiv = document.getElementById("levelSelect");
const levelButtonsDiv = document.getElementById("levelButtons");

// Lane settings
const LANE_COUNT = 4;
let LANES = [];

// Player
const PLAYER_WIDTH = 40;
const PLAYER_HEIGHT = 80;
const playerImg = new Image();
playerImg.src = 'car2.png'; // Replace with your player image
const player = { lane:1, x:0, y:0, width:PLAYER_WIDTH, height:PLAYER_HEIGHT };

// Obstacles
const OBSTACLE_WIDTH = 40;
const OBSTACLE_HEIGHT = 80;
const obstacleImg = new Image();
obstacleImg.src = 'car2.png'; // Replace with your obstacle image
let obstacles = [];

// Game state
let bgSpeed, lineOffset=0, frame=0, gameOver=false;
let startTime, levelTime=0, levelDuration=30;
let level = 1, obstacleSpeed, spawnRate;

// Controls
let left=false, right=false;

// Level data - faster upper levels
const levelData = [];
for(let i=1;i<=15;i++){
  levelData.push({
    bgSpeed: 4 + i*2.0,
    obstacleSpeed: 2 + i*2.0,
    spawnRate: Math.max(15, 40 - i*2)
  });
}

// Level buttons
for(let i=1;i<=15;i++){
  const btn = document.createElement("button");
  btn.textContent = i;
  btn.onclick = ()=>startLevel(i);
  levelButtonsDiv.appendChild(btn);
}

// Keyboard
document.addEventListener("keydown", e => { 
  if(e.key==="ArrowLeft") left=true; 
  if(e.key==="ArrowRight") right=true; 
});
document.addEventListener("keyup", e => { 
  if(e.key==="ArrowLeft") left=false; 
  if(e.key==="ArrowRight") right=false; 
});

// Touch swipe
let touchStartX = null;
canvas.addEventListener("touchstart", e => { touchStartX = e.touches[0].clientX; });
canvas.addEventListener("touchend", e => {
  if(touchStartX === null) return;
  const diff = e.changedTouches[0].clientX - touchStartX;
  if(diff > 30) right = true;
  else if(diff < -30) left = true;
  touchStartX = null;
});

// Calculate lane centers
function updateLaneCenters() {
  const margin = 20;
  const roadWidth = canvas.width - 2 * margin;
  const laneWidth = roadWidth / LANE_COUNT;
  LANES = [];
  for(let i=0;i<LANE_COUNT;i++){
    LANES.push(margin + i*laneWidth + laneWidth/2);
  }
}
updateLaneCenters();

// Start level
function startLevel(lvl){
  level = lvl;
  const data = levelData[lvl-1];
  bgSpeed = data.bgSpeed;
  obstacleSpeed = data.obstacleSpeed;
  spawnRate = data.spawnRate;

  lineOffset=0; frame=0; gameOver=false; obstacles=[];
  levelTime=0; startTime = Date.now();

  player.lane = 1;
  player.x = LANES[player.lane] - player.width/2;
  player.y = canvas.height - 100;

  levelSelectDiv.style.display="none";
  canvas.style.display="block";
  gameOverScreen.style.display="none";
}

function showLevelSelect(){
  canvas.style.display="none";
  gameOverScreen.style.display="none";
  levelSelectDiv.style.display="block";
}

function resetGame(){ 
    const crashAudio = document.getElementById("crashSound");
  crashAudio.pause();
  crashAudio.currentTime = 0;
    startLevel(level); 
}

// Spawn obstacle - always leave at least one free lane
function spawnObstacle() {
  const occupiedLanes = obstacles
    .filter(o => o.y < OBSTACLE_HEIGHT*2)
    .map(o => LANES.findIndex(laneX => Math.abs(o.x + OBSTACLE_WIDTH/2 - laneX) < 1));

  const freeLanes = [];
  for(let i=0;i<LANE_COUNT;i++){
    if(!occupiedLanes.includes(i)) freeLanes.push(i);
  }
  if(freeLanes.length === 0) return;

  const lane = freeLanes[Math.floor(Math.random() * freeLanes.length)];
  obstacles.push({x: LANES[lane]-OBSTACLE_WIDTH/2, y:-OBSTACLE_HEIGHT, width: OBSTACLE_WIDTH, height: OBSTACLE_HEIGHT});
}

// Update obstacles
function updateObstacles() {
  for(let i=obstacles.length-1;i>=0;i--){
    obstacles[i].y += obstacleSpeed;
    if(obstacles[i].y>canvas.height) obstacles.splice(i,1);
  }
}

// Collision
function checkCollision(a,b){
  return a.x < b.x + b.width && a.x + a.width > b.x &&
         a.y < b.y + b.height && a.y + a.height > b.y;
}

// Game update
function update() {
  if(gameOver) return;

  if(left){ player.lane = Math.max(0, player.lane-1); left=false; }
  if(right){ player.lane = Math.min(LANE_COUNT-1, player.lane+1); right=false; }
  player.x = LANES[player.lane] - player.width/2;

  lineOffset += bgSpeed;
  if(lineOffset>40) lineOffset=0;

  frame++;
  if(frame % Math.floor(spawnRate) === 0) spawnObstacle();
  updateObstacles();

  for(const obs of obstacles){
    if(checkCollision(player, obs)){
      gameOver = true;

      // Play crash sound
      const crashAudio = document.getElementById("crashSound");
      crashAudio.currentTime = 0;
      crashAudio.play();

      finalTimeText.textContent = `Time Survived: ${((Date.now()-startTime)/1000).toFixed(2)}s`;
      gameOverScreen.style.display = "block";
      return;
    }
  }

  levelTime = (Date.now()-startTime)/1000;
  if(levelTime >= levelDuration){
    gameOver = true;
    gameOverText.textContent="Level Completed!";
    finalTimeText.textContent = `You completed level ${level}!`;
    gameOverScreen.style.display="block";
  }
}

// Draw
function drawBackground(){
  ctx.fillStyle="#555";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  ctx.fillStyle="#222";
  ctx.fillRect(0,0,20,canvas.height);
  ctx.fillRect(canvas.width-20,0,20,canvas.height);

  ctx.strokeStyle="#eee";
  ctx.lineWidth=4;
  ctx.setLineDash([20,20]);
  ctx.lineDashOffset=-lineOffset;

  const roadWidth = canvas.width - 40;
  for(let i=1;i<LANE_COUNT;i++){
    const x = 20 + i*(roadWidth/LANE_COUNT);
    ctx.beginPath();
    ctx.moveTo(x,0);
    ctx.lineTo(x,canvas.height);
    ctx.stroke();
  }
  ctx.setLineDash([]);
}

function drawObstacles(){ obstacles.forEach(o => ctx.drawImage(obstacleImg, o.x, o.y, o.width, o.height)); }
function drawPlayer(){ ctx.drawImage(playerImg, player.x, player.y, player.width, player.height); }

function drawHUD(){
  ctx.fillStyle="white";
  ctx.font="20px Arial";
  ctx.fillText(`Level: ${level}`,10,30);
  if(!gameOver){
    ctx.fillText(`Time: ${(levelDuration-levelTime).toFixed(2)}s`, canvas.width-120,30);
  }
}

// Game loop
function gameLoop(){
  if(canvas.style.display === "block"){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawBackground();
    update();
    drawObstacles();
    drawPlayer();
    drawHUD();
  }
  requestAnimationFrame(gameLoop);
}

gameLoop();
</script>
</body>
</html>
